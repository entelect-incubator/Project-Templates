//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.6.2.0 (NJsonSchema v11.5.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* eslint-disable */
// ReSharper disable InconsistentNaming

namespace PizzaApi {

export class PizzaApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl ?? "https://localhost:7160";
    }

    getHc(): Promise<void> {
        let url_ = this.baseUrl + "/hc";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGetHc(_response);
        });
    }

    protected processGetHc(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    /**
     * Create a new pizza
     */
    create_a_pizza(command: CreatePizzaCommand): Promise<ResultOfPizzaModel> {
        let url_ = this.baseUrl + "/v1/pizzas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate_a_pizza(_response);
        });
    }

    protected processCreate_a_pizza(response: Response): Promise<ResultOfPizzaModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPizzaModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationErrorResult.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResult.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultOfPizzaModel>(null as any);
    }

    /**
     * Update existing pizza
     */
    update_pizza(command: UpdatePizzaCommand): Promise<ResultOfPizzaModel> {
        let url_ = this.baseUrl + "/v1/pizzas";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUpdate_pizza(_response);
        });
    }

    protected processUpdate_pizza(response: Response): Promise<ResultOfPizzaModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfPizzaModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationErrorResult.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 404) {
            return response.text().then((_responseText) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = NotFoundErrorResult.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResult.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultOfPizzaModel>(null as any);
    }

    /**
     * Search for pizzas
     */
    search_for_pizzas(query: GetAllPizzasQuery): Promise<ResultOfIEnumerableOfPizzaModel> {
        let url_ = this.baseUrl + "/v1/pizzassearch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSearch_for_pizzas(_response);
        });
    }

    protected processSearch_for_pizzas(response: Response): Promise<ResultOfIEnumerableOfPizzaModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfIEnumerableOfPizzaModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationErrorResult.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResult.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultOfIEnumerableOfPizzaModel>(null as any);
    }

    /**
     * Complete an order
     */
    complete_order(command: CompleteOrderCommand): Promise<ResultOfOrderModel> {
        let url_ = this.baseUrl + "/v1/pizzasorder/complete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processComplete_order(_response);
        });
    }

    protected processComplete_order(response: Response): Promise<ResultOfOrderModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationErrorResult.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResult.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultOfOrderModel>(null as any);
    }

    /**
     * Create a new order
     */
    create_order(command: CreateOrderCommand): Promise<ResultOfOrderModel> {
        let url_ = this.baseUrl + "/v1/pizzasorder";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processCreate_order(_response);
        });
    }

    protected processCreate_order(response: Response): Promise<ResultOfOrderModel> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderModel.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationErrorResult.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResult.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultOfOrderModel>(null as any);
    }

    /**
     * Get the status of an order
     */
    get_order_status(id: number): Promise<ResultOfOrderStatus> {
        let url_ = this.baseUrl + "/v1/pizzasorder/status/{id}";
        if (id === undefined || id === null)
            throw new globalThis.Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processGet_order_status(_response);
        });
    }

    protected processGet_order_status(response: Response): Promise<ResultOfOrderStatus> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResultOfOrderStatus.fromJS(resultData200);
            return result200;
            });
        } else if (status === 400) {
            return response.text().then((_responseText) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationErrorResult.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            });
        } else if (status === 500) {
            return response.text().then((_responseText) => {
            let result500: any = null;
            let resultData500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result500 = ErrorResult.fromJS(resultData500);
            return throwException("A server side error occurred.", status, _responseText, _headers, result500);
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ResultOfOrderStatus>(null as any);
    }
}

export abstract class ResultBase implements IResultBase {
    errorResult?: ErrorResults;
    message?: string | undefined;
    errors?: string[];
    validationErrors?: { [key: string]: string[]; };
    hasError?: boolean;

    constructor(data?: IResultBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.errorResult = _data["ErrorResult"];
            this.message = _data["Message"];
            if (Array.isArray(_data["Errors"])) {
                this.errors = [] as any;
                for (let item of _data["Errors"])
                    this.errors!.push(item);
            }
            if (_data["ValidationErrors"]) {
                this.validationErrors = {} as any;
                for (let key in _data["ValidationErrors"]) {
                    if (_data["ValidationErrors"].hasOwnProperty(key))
                        (this.validationErrors as any)![key] = _data["ValidationErrors"][key] !== undefined ? _data["ValidationErrors"][key] : [];
                }
            }
            this.hasError = _data["HasError"];
        }
    }

    static fromJS(data: any): ResultBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ResultBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ErrorResult"] = this.errorResult;
        data["Message"] = this.message;
        if (Array.isArray(this.errors)) {
            data["Errors"] = [];
            for (let item of this.errors)
                data["Errors"].push(item);
        }
        if (this.validationErrors) {
            data["ValidationErrors"] = {};
            for (let key in this.validationErrors) {
                if (this.validationErrors.hasOwnProperty(key))
                    (data["ValidationErrors"] as any)[key] = (this.validationErrors as any)[key];
            }
        }
        data["HasError"] = this.hasError;
        return data;
    }
}

export interface IResultBase {
    errorResult?: ErrorResults;
    message?: string | undefined;
    errors?: string[];
    validationErrors?: { [key: string]: string[]; };
    hasError?: boolean;
}

export class ResultOfPizzaModel extends ResultBase implements IResultOfPizzaModel {
    data?: PizzaModel;
    count?: number;

    constructor(data?: IResultOfPizzaModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["Data"] ? PizzaModel.fromJS(_data["Data"]) : undefined as any;
            this.count = _data["Count"];
        }
    }

    static override fromJS(data: any): ResultOfPizzaModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfPizzaModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data ? this.data.toJSON() : undefined as any;
        data["Count"] = this.count;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfPizzaModel extends IResultBase {
    data?: PizzaModel;
    count?: number;
}

export class PizzaModel implements IPizzaModel {
    id?: number;
    name?: string;
    dateCreated?: Date | undefined;
    disabled?: boolean | undefined;

    constructor(data?: IPizzaModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.name = _data["Name"];
            this.dateCreated = _data["DateCreated"] ? new Date(_data["DateCreated"].toString()) : undefined as any;
            this.disabled = _data["Disabled"];
        }
    }

    static fromJS(data: any): PizzaModel {
        data = typeof data === 'object' ? data : {};
        let result = new PizzaModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Name"] = this.name;
        data["DateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : undefined as any;
        data["Disabled"] = this.disabled;
        return data;
    }
}

export interface IPizzaModel {
    id?: number;
    name?: string;
    dateCreated?: Date | undefined;
    disabled?: boolean | undefined;
}

export enum ErrorResults {
    None = 0,
    ValidationError = 1,
    NotFound = 2,
    GeneralError = 3,
}

export class Result extends ResultBase implements IResult {

    constructor(data?: IResult) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IResult extends IResultBase {
}

export class ValidationErrorResult extends Result implements IValidationErrorResult {
    isError?: boolean;
    isValidationError?: boolean;

    constructor(data?: IValidationErrorResult) {
        super(data);
        if (!data) {
            this.isError = false;
            this.isValidationError = true;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isError = _data["IsError"] !== undefined ? _data["IsError"] : false;
            this.isValidationError = _data["IsValidationError"] !== undefined ? _data["IsValidationError"] : true;
        }
    }

    static override fromJS(data: any): ValidationErrorResult {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsError"] = this.isError;
        data["IsValidationError"] = this.isValidationError;
        super.toJSON(data);
        return data;
    }
}

export interface IValidationErrorResult extends IResult {
    isError?: boolean;
    isValidationError?: boolean;
}

export class ErrorResult extends Result implements IErrorResult {
    isError?: boolean;
    isValidationError?: boolean;

    constructor(data?: IErrorResult) {
        super(data);
        if (!data) {
            this.isError = true;
            this.isValidationError = false;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isError = _data["IsError"] !== undefined ? _data["IsError"] : true;
            this.isValidationError = _data["IsValidationError"] !== undefined ? _data["IsValidationError"] : false;
        }
    }

    static override fromJS(data: any): ErrorResult {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsError"] = this.isError;
        data["IsValidationError"] = this.isValidationError;
        super.toJSON(data);
        return data;
    }
}

export interface IErrorResult extends IResult {
    isError?: boolean;
    isValidationError?: boolean;
}

export class CreatePizzaCommand implements ICreatePizzaCommand {
    name?: string;

    constructor(data?: ICreatePizzaCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): CreatePizzaCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePizzaCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        return data;
    }
}

export interface ICreatePizzaCommand {
    name?: string;
}

export class ResultOfIEnumerableOfPizzaModel extends ResultBase implements IResultOfIEnumerableOfPizzaModel {
    data?: PizzaModel[];
    count?: number;

    constructor(data?: IResultOfIEnumerableOfPizzaModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["Data"])) {
                this.data = [] as any;
                for (let item of _data["Data"])
                    this.data!.push(PizzaModel.fromJS(item));
            }
            this.count = _data["Count"];
        }
    }

    static override fromJS(data: any): ResultOfIEnumerableOfPizzaModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfIEnumerableOfPizzaModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["Data"] = [];
            for (let item of this.data)
                data["Data"].push(item ? item.toJSON() : undefined as any);
        }
        data["Count"] = this.count;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfIEnumerableOfPizzaModel extends IResultBase {
    data?: PizzaModel[];
    count?: number;
}

export class BaseSearchModel implements IBaseSearchModel {
    orderBy?: string;
    sortDirection?: SortDirection;
    ordering?: string;
    pagingArgs?: PagingArgs | undefined;

    constructor(data?: IBaseSearchModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.orderBy = _data["OrderBy"];
            this.sortDirection = _data["SortDirection"];
            this.ordering = _data["Ordering"];
            this.pagingArgs = _data["PagingArgs"] ? PagingArgs.fromJS(_data["PagingArgs"]) : undefined as any;
        }
    }

    static fromJS(data: any): BaseSearchModel {
        data = typeof data === 'object' ? data : {};
        let result = new BaseSearchModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["OrderBy"] = this.orderBy;
        data["SortDirection"] = this.sortDirection;
        data["Ordering"] = this.ordering;
        data["PagingArgs"] = this.pagingArgs ? this.pagingArgs.toJSON() : undefined as any;
        return data;
    }
}

export interface IBaseSearchModel {
    orderBy?: string;
    sortDirection?: SortDirection;
    ordering?: string;
    pagingArgs?: PagingArgs | undefined;
}

export class GetAllPizzasQuery extends BaseSearchModel implements IGetAllPizzasQuery {
    name?: string | undefined;

    constructor(data?: IGetAllPizzasQuery) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["Name"];
        }
    }

    static override fromJS(data: any): GetAllPizzasQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllPizzasQuery();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        super.toJSON(data);
        return data;
    }
}

export interface IGetAllPizzasQuery extends IBaseSearchModel {
    name?: string | undefined;
}

export enum SortDirection {
    Ascending = "Ascending",
    Descending = "Descending",
}

export class PagingArgs implements IPagingArgs {
    pageNumber?: number;
    pageSize?: number;
    skipAmount?: number;
    usePaging?: boolean;

    constructor(data?: IPagingArgs) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["PageNumber"];
            this.pageSize = _data["PageSize"];
            this.skipAmount = _data["SkipAmount"];
            this.usePaging = _data["UsePaging"];
        }
    }

    static fromJS(data: any): PagingArgs {
        data = typeof data === 'object' ? data : {};
        let result = new PagingArgs();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PageNumber"] = this.pageNumber;
        data["PageSize"] = this.pageSize;
        data["SkipAmount"] = this.skipAmount;
        data["UsePaging"] = this.usePaging;
        return data;
    }
}

export interface IPagingArgs {
    pageNumber?: number;
    pageSize?: number;
    skipAmount?: number;
    usePaging?: boolean;
}

export class NotFoundErrorResult extends Result implements INotFoundErrorResult {
    isNotFound?: boolean;

    constructor(data?: INotFoundErrorResult) {
        super(data);
        if (!data) {
            this.isNotFound = true;
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.isNotFound = _data["IsNotFound"] !== undefined ? _data["IsNotFound"] : true;
        }
    }

    static override fromJS(data: any): NotFoundErrorResult {
        data = typeof data === 'object' ? data : {};
        let result = new NotFoundErrorResult();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["IsNotFound"] = this.isNotFound;
        super.toJSON(data);
        return data;
    }
}

export interface INotFoundErrorResult extends IResult {
    isNotFound?: boolean;
}

export class UpdatePizzaCommand implements IUpdatePizzaCommand {
    id?: number;
    model?: UpdatePizzaModel;

    constructor(data?: IUpdatePizzaCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.model = _data["Model"] ? UpdatePizzaModel.fromJS(_data["Model"]) : undefined as any;
        }
    }

    static fromJS(data: any): UpdatePizzaCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePizzaCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["Model"] = this.model ? this.model.toJSON() : undefined as any;
        return data;
    }
}

export interface IUpdatePizzaCommand {
    id?: number;
    model?: UpdatePizzaModel;
}

export class UpdatePizzaModel implements IUpdatePizzaModel {
    name?: string | undefined;
    disabled?: boolean | undefined;

    constructor(data?: IUpdatePizzaModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.disabled = _data["Disabled"];
        }
    }

    static fromJS(data: any): UpdatePizzaModel {
        data = typeof data === 'object' ? data : {};
        let result = new UpdatePizzaModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Disabled"] = this.disabled;
        return data;
    }
}

export interface IUpdatePizzaModel {
    name?: string | undefined;
    disabled?: boolean | undefined;
}

export class ResultOfOrderModel extends ResultBase implements IResultOfOrderModel {
    data?: OrderModel;
    count?: number;

    constructor(data?: IResultOfOrderModel) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["Data"] ? OrderModel.fromJS(_data["Data"]) : undefined as any;
            this.count = _data["Count"];
        }
    }

    static override fromJS(data: any): ResultOfOrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfOrderModel();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data ? this.data.toJSON() : undefined as any;
        data["Count"] = this.count;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfOrderModel extends IResultBase {
    data?: OrderModel;
    count?: number;
}

export class OrderModel implements IOrderModel {
    id?: number;
    customerName?: string;
    customerEmail?: string;
    pizzaId?: number;
    status?: OrderStatus;
    dateCreated?: Date;

    constructor(data?: IOrderModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
            this.customerName = _data["CustomerName"];
            this.customerEmail = _data["CustomerEmail"];
            this.pizzaId = _data["PizzaId"];
            this.status = _data["Status"];
            this.dateCreated = _data["DateCreated"] ? new Date(_data["DateCreated"].toString()) : undefined as any;
        }
    }

    static fromJS(data: any): OrderModel {
        data = typeof data === 'object' ? data : {};
        let result = new OrderModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        data["CustomerName"] = this.customerName;
        data["CustomerEmail"] = this.customerEmail;
        data["PizzaId"] = this.pizzaId;
        data["Status"] = this.status;
        data["DateCreated"] = this.dateCreated ? this.dateCreated.toISOString() : undefined as any;
        return data;
    }
}

export interface IOrderModel {
    id?: number;
    customerName?: string;
    customerEmail?: string;
    pizzaId?: number;
    status?: OrderStatus;
    dateCreated?: Date;
}

export enum OrderStatus {
    Confirmed = 0,
    Making = 1,
    Complete = 2,
    SentOutForDelivery = 3,
}

export class CompleteOrderCommand implements ICompleteOrderCommand {
    id?: number;

    constructor(data?: ICompleteOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["Id"];
        }
    }

    static fromJS(data: any): CompleteOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Id"] = this.id;
        return data;
    }
}

export interface ICompleteOrderCommand {
    id?: number;
}

export class CreateOrderCommand implements ICreateOrderCommand {
    customerName?: string;
    customerEmail?: string;
    pizzaId?: number;

    constructor(data?: ICreateOrderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (this as any)[property] = (data as any)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.customerName = _data["CustomerName"];
            this.customerEmail = _data["CustomerEmail"];
            this.pizzaId = _data["PizzaId"];
        }
    }

    static fromJS(data: any): CreateOrderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["CustomerName"] = this.customerName;
        data["CustomerEmail"] = this.customerEmail;
        data["PizzaId"] = this.pizzaId;
        return data;
    }
}

export interface ICreateOrderCommand {
    customerName?: string;
    customerEmail?: string;
    pizzaId?: number;
}

export class ResultOfOrderStatus extends ResultBase implements IResultOfOrderStatus {
    data?: OrderStatus;
    count?: number;

    constructor(data?: IResultOfOrderStatus) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.data = _data["Data"];
            this.count = _data["Count"];
        }
    }

    static override fromJS(data: any): ResultOfOrderStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ResultOfOrderStatus();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Data"] = this.data;
        data["Count"] = this.count;
        super.toJSON(data);
        return data;
    }
}

export interface IResultOfOrderStatus extends IResultBase {
    data?: OrderStatus;
    count?: number;
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}

}